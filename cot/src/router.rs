use std::sync::Arc;

use cot_core::request::{Request, RequestHead};
pub use cot_core::reverse_param_map;
#[doc(inline)]
pub use cot_core::router::{Route, Router, RouterService, method};

use crate::request::RequestExt;

/// Get a URL for a view by its registered name and given params.
///
/// If the view name has two parts separated by a colon, the first part is
/// considered the app name. If the app name is not provided, the app name of
/// the request is used. This means that if you don't specify the `app_name`,
/// this macro will only return URLs for views in the same app as the current
/// request handler.
///
/// # Return value
///
/// Returns a [`crate::Result<String>`] that contains the URL for the view. You
/// will typically want to append `?` to the macro call to get the URL.
///
/// # Examples
///
/// ```
/// use cot::html::Html;
/// use cot::project::RegisterAppsContext;
/// use cot::{App, AppBuilder, Project, StatusCode, reverse};
/// use cot_core::request::Request;
/// use cot_core::router::{Route, Router};
///
/// async fn home(request: Request) -> cot::Result<Html> {
///     // any of below two lines returns the same:
///     let url = reverse!(request, "home")?;
///     let url = reverse!(request, "my_custom_app:home")?;
///
///     Ok(Html::new(format!(
///         "Hello! The URL for this view is: {}",
///         url
///     )))
/// }
///
/// let router = Router::with_urls([Route::with_handler_and_name("/", home, "home")]);
///
/// struct MyApp;
///
/// impl App for MyApp {
///     fn name(&self) -> &'static str {
///         "my_custom_app"
///     }
///
///     fn router(&self) -> Router {
///         Router::with_urls([Route::with_handler_and_name("/", home, "home")])
///     }
/// }
///
/// struct MyProject;
///
/// impl Project for MyProject {
///     fn register_apps(&self, apps: &mut AppBuilder, context: &RegisterAppsContext) {
///         apps.register_with_views(MyApp, "");
///     }
/// }
/// ```
#[macro_export]
macro_rules! reverse {
    ($request:expr, $view_name:literal $(, $($key:ident = $value:expr),*)?) => {{
        #[allow(
            clippy::allow_attributes,
            unused_imports,
            reason = "allow using either `Request` or `Urls` objects"
        )]
        use $crate::request::RequestExt;
        let (app_name, view_name) = $crate::router::split_view_name($view_name);
        let app_name = app_name.or_else(|| $request.app_name());
        $request
            .router()
            .reverse(app_name, view_name, &$crate::router::reverse_param_map!($( $($key = $value),* )?))
    }};
}

// used in the reverse! macro; not part of public API
#[doc(hidden)]
#[must_use]
pub fn split_view_name(view_name: &str) -> (Option<&str>, &str) {
    let colon_pos = view_name.find(':');
    if let Some(colon_pos) = colon_pos {
        let app_name = &view_name[..colon_pos];
        let view_name = &view_name[colon_pos + 1..];
        (Some(app_name), view_name)
    } else {
        (None, view_name)
    }
}

/// Get a URL for a view by its registered name and given params and return a
/// response with a redirect.
///
/// This macro is a shorthand for creating a response with a redirect to a URL
/// generated by the [`reverse!`] macro.
///
/// # Return value
///
/// Returns a [`crate::Result<Response>`] that contains the URL for
/// the view. You will typically want to append `?` to the macro call to get the
/// [`Response`] object.
///
/// # Examples
///
/// ```
/// use cot::reverse_redirect;
/// use cot_core::request::Request;
/// use cot_core::response::Response;
/// use cot_core::router::{Route, Router};
///
/// async fn infinite_loop(request: Request) -> cot::Result<Response> {
///     Ok(reverse_redirect!(request, "home")?)
/// }
///
/// let router = Router::with_urls([Route::with_handler_and_name("/", infinite_loop, "home")]);
/// ```
#[macro_export]
macro_rules! reverse_redirect {
    ($request:expr, $view_name:literal $(, $($key:ident = $value:expr),*)?) => {
        $crate::reverse!(
            $request,
            $view_name,
            $( $($key = $value),* )?
        ).map(|url| <$crate::response::Response as $crate::response::ResponseExt>::new_redirect(url))
    };
}

/// A helper structure to allow reversing URLs from a request handler.
///
/// This is mainly useful as an extractor to allow reversing URLs without
/// access to a full [`Request`] object.
///
/// # Examples
///
/// ```
/// use cot::html::Html;
/// use cot::test::TestRequestBuilder;
/// use cot::{RequestHandler, reverse};
/// use cot_core::router::{Route, Router, Urls};
///
/// async fn my_handler(urls: Urls) -> cot::Result<Html> {
///     let url = reverse!(urls, "home")?;
///     Ok(Html::new(format!("{url}")))
/// }
///
/// # #[tokio::main]
/// # async fn main() -> cot::Result<()> {
/// let router = Router::with_urls([Route::with_handler_and_name("/", my_handler, "home")]);
/// let request = TestRequestBuilder::get("/").router(router).build();
///
/// assert_eq!(
///     my_handler
///         .handle(request)
///         .await?
///         .into_body()
///         .into_bytes()
///         .await?,
///     "/"
/// );
/// # Ok(())
/// # }
/// ```
#[derive(Debug, Clone)]
pub struct Urls {
    app_name: Option<String>,
    router: Arc<Router>,
}

impl Urls {
    /// Create a new `Urls` object from a [`Request`] object.
    ///
    /// # Examples
    ///
    /// ```
    /// use cot::html::Html;
    /// use cot::{Body, StatusCode, reverse};
    /// use cot_core::request::Request;
    /// use cot_core::response::{Response, ResponseExt};
    /// use cot_core::router::Urls;
    ///
    /// async fn my_handler(request: Request) -> cot::Result<Html> {
    ///     let urls = Urls::from_request(&request);
    ///     let url = reverse!(urls, "home")?;
    ///     Ok(Html::new(format!(
    ///         "Hello! The URL for this view is: {}",
    ///         url
    ///     )))
    /// }
    /// ```
    pub fn from_request(request: &Request) -> Self {
        Self {
            app_name: request.app_name().map(ToOwned::to_owned),
            router: Arc::clone(request.router()),
        }
    }

    pub fn from_parts(request_head: &RequestHead) -> Self {
        Self {
            app_name: request_head.app_name().map(ToOwned::to_owned),
            router: Arc::clone(request_head.router()),
        }
    }

    /// Get the app name the current route belongs to, or [`None`] if the
    /// request is not routed.
    ///
    /// This is mainly useful for providing context to reverse redirects, where
    /// you want to redirect to a route in the same app.
    ///
    /// # Examples
    ///
    /// ```
    /// use cot_core::request::{Request, RequestExt};
    /// use cot_core::response::Response;
    /// use cot_core::router::Urls;
    ///
    /// async fn my_handler(urls: Urls) -> cot::Result<Response> {
    ///     let app_name = urls.app_name();
    ///     // ... do something with the app name
    ///     # unimplemented!()
    /// }
    /// ```
    #[must_use]
    pub fn app_name(&self) -> Option<&str> {
        self.app_name.as_deref()
    }

    /// Get the router.
    ///
    /// # Examples
    ///
    /// ```
    /// use cot_core::request::{Request, RequestExt};
    /// use cot_core::response::Response;
    /// use cot_core::router::Urls;
    ///
    /// async fn my_handler(urls: Urls) -> cot::Result<Response> {
    ///     let router = urls.router();
    ///     // ... do something with the router
    ///     # unimplemented!()
    /// }
    /// ```
    #[must_use]
    pub fn router(&self) -> &Router {
        &self.router
    }
}
