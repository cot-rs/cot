use std::any::Any;
use std::panic::PanicHookInfo;
use std::sync::Arc;

use askama::Template;
use log::error;

use crate::router::Router;
use crate::{Error, Result, StatusCode};

/// Added as a Response extension to trigger displaying the error page.
///
/// If the global request handler finds this in a response generated by a router
/// or view, it intercepts the response (given that
/// [`crate::config::DISPLAY_ERROR_PAGE`] is `true`) and displays the error page
/// instead.
#[derive(Debug, Copy, Clone)]
pub(crate) enum ErrorPageTrigger {
    NotFound,
}

#[derive(Debug)]
pub(super) struct FlareonDiagnostics {
    router: Arc<Router>,
    request_parts: Option<http::request::Parts>,
}

impl FlareonDiagnostics {
    #[must_use]
    pub(super) fn new(router: Arc<Router>, request_parts: Option<http::request::Parts>) -> Self {
        Self {
            router,
            request_parts,
        }
    }
}

#[derive(Debug, Template)]
#[template(path = "error.html")]
struct ErrorPageTemplate {
    kind: Kind,
    panic_string: Option<String>,
    panic_location: Option<String>,
    backtrace: Option<Backtrace>,
    error_data: Vec<ErrorData>,
    route_data: Vec<RouteData>,
    request_data: Option<RequestData>,
}

#[derive(Debug, Default, Clone)]
struct ErrorPageTemplateBuilder {
    kind: Kind,
    panic_string: Option<String>,
    panic_location: Option<String>,
    backtrace: Option<Backtrace>,
    error_data: Vec<ErrorData>,
    route_data: Vec<RouteData>,
    request_data: Option<RequestData>,
}

impl ErrorPageTemplateBuilder {
    #[must_use]
    fn not_found() -> Self {
        Self {
            kind: Kind::NotFound,
            ..Default::default()
        }
    }

    #[must_use]
    fn error(error: Error) -> Self {
        let mut error_data = Vec::new();
        Self::build_error_data(&mut error_data, &error);

        Self {
            kind: Kind::Error,
            error_data,
            ..Default::default()
        }
    }

    #[must_use]
    fn panic(panic_payload: Box<dyn Any + Send>) -> Self {
        Self {
            kind: Kind::Panic,
            panic_string: Self::get_panic_string(panic_payload),
            panic_location: PANIC_LOCATION.take(),
            backtrace: PANIC_BACKTRACE.take(),
            ..Default::default()
        }
    }

    fn diagnostics(&mut self, diagnostics: FlareonDiagnostics) -> &mut Self {
        self.route_data.clear();
        Self::build_route_data(&mut self.route_data, &diagnostics.router, "", "");
        self.request_data = diagnostics
            .request_parts
            .as_ref()
            .map(Self::build_request_data);
        self
    }

    fn build_route_data(
        route_data: &mut Vec<RouteData>,
        router: &Router,
        url_prefix: &str,
        index_prefix: &str,
    ) {
        for (index, route) in router.routes().iter().enumerate() {
            route_data.push(RouteData {
                index: format!("{index_prefix}{index}"),
                path: route.url(),
                kind: match route.kind() {
                    crate::router::RouteKind::Router => if route_data.is_empty() {
                        "Root Router"
                    } else {
                        "Router"
                    }
                    .to_owned(),
                    crate::router::RouteKind::Handler => "View".to_owned(),
                },
                name: route.name().unwrap_or_default().to_owned(),
            });

            if let Some(inner_router) = route.router() {
                Self::build_route_data(
                    route_data,
                    inner_router,
                    &format!("{}{}", url_prefix, route.url()),
                    &format!("{index_prefix}{index}."),
                );
            }
        }
    }

    fn build_error_data(vec: &mut Vec<ErrorData>, error: &(dyn std::error::Error + 'static)) {
        let data = ErrorData {
            description: error.to_string(),
            debug_str: format!("{error:#?}"),
            is_flareon_error: error.is::<Error>(),
        };
        vec.push(data);

        if let Some(source) = error.source() {
            Self::build_error_data(vec, source);
        }
    }

    #[must_use]
    fn build_request_data(parts: &http::request::Parts) -> RequestData {
        RequestData {
            method: parts.method.to_string(),
            url: parts.uri.to_string(),
            protocol_version: format!("{:?}", parts.version),
            headers: parts
                .headers
                .iter()
                .map(|(name, value)| {
                    (
                        name.as_str().to_owned(),
                        String::from_utf8_lossy(value.as_ref()).into_owned(),
                    )
                })
                .collect(),
        }
    }

    #[must_use]
    fn get_panic_string(panic_payload: Box<dyn Any + Send>) -> Option<String> {
        if let Some(&panic_string) = panic_payload.downcast_ref::<&str>() {
            Some(panic_string.to_owned())
        } else {
            panic_payload.downcast_ref::<String>().cloned()
        }
    }

    fn render(&self) -> askama::Result<String> {
        ErrorPageTemplate {
            kind: self.kind,
            panic_string: self.panic_string.clone(),
            panic_location: self.panic_location.clone(),
            backtrace: self.backtrace.clone(),
            error_data: self.error_data.clone(),
            route_data: self.route_data.clone(),
            request_data: self.request_data.clone(),
        }
        .render()
    }
}

#[derive(Debug, Copy, Clone, PartialEq, Eq, Default)]
enum Kind {
    NotFound,
    #[default]
    Error,
    Panic,
}

#[derive(Debug, Clone)]
struct ErrorData {
    description: String,
    debug_str: String,
    is_flareon_error: bool,
}

#[derive(Debug, Clone)]
struct RouteData {
    index: String,
    path: String,
    kind: String,
    name: String,
}

#[derive(Debug, Clone)]
struct RequestData {
    method: String,
    url: String,
    protocol_version: String,
    headers: Vec<(String, String)>,
}

#[must_use]
pub(super) fn handle_not_found(diagnostics: FlareonDiagnostics) -> axum::response::Response {
    build_response(build_not_found_response(diagnostics), StatusCode::NOT_FOUND)
}

#[must_use]
pub(super) fn handle_response_panic(
    panic_payload: Box<dyn Any + Send>,
    diagnostics: FlareonDiagnostics,
) -> axum::response::Response {
    build_response(
        build_panic_response(panic_payload, diagnostics),
        StatusCode::INTERNAL_SERVER_ERROR,
    )
}

#[must_use]
pub(super) fn handle_response_error(
    error: Error,
    diagnostics: FlareonDiagnostics,
) -> axum::response::Response {
    build_response(
        build_error_response(error, diagnostics),
        StatusCode::INTERNAL_SERVER_ERROR,
    )
}

#[must_use]
fn build_response(
    response_string: Result<String>,
    status_code: StatusCode,
) -> axum::response::Response {
    match response_string {
        Ok(error_str) => axum::response::Response::builder()
            .status(status_code)
            .body(axum::body::Body::new(error_str))
            .unwrap_or_else(|_| build_flareon_failure_page()),
        Err(error) => {
            error!("Failed to render error page: {}", error);
            build_flareon_failure_page()
        }
    }
}

fn build_not_found_response(diagnostics: FlareonDiagnostics) -> Result<String> {
    Ok(ErrorPageTemplateBuilder::not_found()
        .diagnostics(diagnostics)
        .render()?)
}

fn build_panic_response(
    panic_payload: Box<dyn Any + Send>,
    diagnostics: FlareonDiagnostics,
) -> Result<String> {
    Ok(ErrorPageTemplateBuilder::panic(panic_payload)
        .diagnostics(diagnostics)
        .render()?)
}

fn build_error_response(error: Error, diagnostics: FlareonDiagnostics) -> Result<String> {
    Ok(ErrorPageTemplateBuilder::error(error)
        .diagnostics(diagnostics)
        .render()?)
}

const FAILURE_PAGE: &[u8] = include_bytes!("../templates/fail.html");

/// A last-resort error page.
///
/// This page is displayed when an error occurs that prevents Flareon from
/// rendering a proper error page. This page is very simple and should only be
/// displayed in the event of a catastrophic failure, likely caused by a bug in
/// Flareon itself.
#[must_use]
fn build_flareon_failure_page() -> axum::response::Response {
    axum::response::Response::builder()
        .status(StatusCode::INTERNAL_SERVER_ERROR)
        .body(axum::body::Body::from(FAILURE_PAGE))
        .expect("Building the Flareon failure page should not fail")
}

thread_local! {
    static PANIC_LOCATION: std::cell::RefCell<Option<String>> = const { std::cell::RefCell::new(None) };
    static PANIC_BACKTRACE: std::cell::RefCell<Option<Backtrace>> = const { std::cell::RefCell::new(None) };
}

pub(super) fn error_page_panic_hook(info: &PanicHookInfo<'_>) {
    let location = info.location().map(|location| format!("{location}"));
    PANIC_LOCATION.replace(location);

    PANIC_BACKTRACE.replace(Some(__flareon_create_backtrace()));
}

// inline(never) is added to make sure there is a separate frame for this
// function so that it can be used to find the start of the backtrace.
#[inline(never)]
fn __flareon_create_backtrace() -> Backtrace {
    let mut backtrace = Vec::new();
    let mut start = false;
    backtrace::trace(|frame| {
        let frame = StackFrame::from(frame);
        if start {
            backtrace.push(frame);
        } else if frame.symbol_name().contains("__flareon_create_backtrace") {
            start = true;
        }

        true
    });

    Backtrace { frames: backtrace }
}

#[derive(Debug, Clone)]
struct Backtrace {
    frames: Vec<StackFrame>,
}

impl Backtrace {
    #[must_use]
    fn frames(&self) -> &[StackFrame] {
        &self.frames
    }
}

#[derive(Debug, Clone)]
struct StackFrame {
    symbol_name: Option<String>,
    filename: Option<String>,
    lineno: Option<u32>,
    colno: Option<u32>,
}

impl StackFrame {
    #[must_use]
    fn symbol_name(&self) -> String {
        self.symbol_name
            .as_deref()
            .unwrap_or("<unknown>")
            .to_string()
    }

    #[must_use]
    fn location(&self) -> String {
        if let Some(filename) = self.filename.as_deref() {
            let mut s = filename.to_owned();

            if let Some(line_no) = self.lineno {
                s = format!("{s}:{line_no}");

                if let Some(col_no) = self.colno {
                    s = format!("{s}:{col_no}");
                }
            }

            s
        } else {
            "<unknown>".to_string()
        }
    }
}

impl From<&backtrace::Frame> for StackFrame {
    fn from(frame: &backtrace::Frame) -> Self {
        let mut symbol_name = None;
        let mut filename = None;
        let mut lineno = None;
        let mut colno = None;

        backtrace::resolve_frame(frame, |symbol| {
            if let Some(name) = symbol.name() {
                symbol_name = Some(name.to_string());
            }
            if let Some(file) = symbol.filename() {
                filename = Some(file.display().to_string());
            }
            if let Some(line) = symbol.lineno() {
                lineno = Some(line);
            }
            if let Some(col) = symbol.colno() {
                colno = Some(col);
            }
        });

        Self {
            symbol_name,
            filename,
            lineno,
            colno,
        }
    }
}
